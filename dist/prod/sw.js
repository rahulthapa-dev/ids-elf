const swUrl=new URL(self.location),baseurl=swUrl.searchParams.get("baseurl")||"";console.info("SW",baseurl);const STATIC_VERSION_HEADER="X-Santa-Version",IGNORE_PROD=["cast","error","upgrade"],PRECACHE=["/","/error.html","/manifest.json","/loader.js","/images/favicon-32.png","/images/icon-192.png","/images/icon-256.png","/images/icon-512.png"];let replacingPreviousServiceWorker=!1;function staticRequestPath(t){if(baseurl){if(baseurl.startsWith("/")){const e=new URL(t);if(e.hostname===location.hostname&&e.pathname.startsWith(baseurl))return e.pathname.substr(baseurl.length)}else if(t.startsWith(baseurl))return t.substr(baseurl.length)}else;}function splitProdPath(t){const e=t.match(/^(\/intl\/.*?)\//),a=e?e[1]:"";let s=t.substr(a.length);const n=s.match(/^\/(?:(\w+)\.html|)(\?|$)/);return n&&!IGNORE_PROD.includes(n[1])&&(s="/"),{intl:a,pathname:s}}self.addEventListener("install",t=>{console.info("SW install");t.waitUntil((async()=>{self.registration.active&&(replacingPreviousServiceWorker=!0);const t=await caches.open("prod");try{await Promise.all(PRECACHE.map(e=>t.add(e)))}catch(t){console.error("failed to fetch",t)}console.info("precached",PRECACHE.length,"prod URLs"),await self.skipWaiting()})())}),self.addEventListener("activate",t=>{console.info("SW activate, replacing:",replacingPreviousServiceWorker);t.waitUntil((async()=>{await self.clients.claim()})())}),self.addEventListener("fetch",t=>{if("GET"!==t.request.method)return;const e=new URL(t.request.url),a=staticRequestPath(t.request.url);if(a){const e=a.split("/",1)[0]||"",s=a.substr(e.length).split("?")[0];if(s.startsWith("/scenes/"))return;const n=s.startsWith("/audio/")||s.startsWith("/fallback-audio/"),r=async()=>{const a=await caches.open("static"),r=await a.match(s);return r&&(n||r.headers.get("X-Santa-Version")===e)?r:fetch(t.request.url).then(async t=>{if(206===t.status)return t;const n={status:t.status,statusText:t.statusText,headers:new Headers(t.headers)};n.headers.set("X-Santa-Version",e);const r=await t.clone().arrayBuffer(),i=new Response(r,n);return await a.put(new Request(s),i),t}).catch(t=>{if(r)return r;throw t})};return void t.respondWith(r())}if(!(location.hostname===e.hostname))return;const{intl:s,pathname:n}=splitProdPath(e.pathname);if(!PRECACHE.includes(n))return;t.respondWith((async()=>{let t;try{t=await fetch(s+n)}catch(t){return(await caches.open("prod")).match(n)}const e=await caches.open("prod");return await e.put(new Request(n),t.clone()),t})())});